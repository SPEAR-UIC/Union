/**********************************************************************
 * This file was generated by coNCePTuaL on Sat Oct  5 18:55:43 2019
 * using the c_union backend (C + UNION).
 * Do not modify this file; modify /Users/xin/macworkspace/union/src/translator/latency.ncptl instead.
 *
 * Entire source program
 * ---------------------
 *   # A ping-pong latency test written in coNCePTuaL
 *
 *   Require language version "1.5".
 *
 *   # Parse the command line.
 *   reps is "Number of repetitions of each message size" and comes from
 *    "--reps" or "-r" with default 1000.
 *   maxbytes is "Maximum number of bytes to transmit" and comes from
 *    "--maxbytes" or "-m" with default 1M.
 *
 *   # Ensure that we have a peer with whom to communicate.
 *   Assert that "the latency test requires at least two tasks" with num_tasks>=2.
 *
 *   # Perform the benchmark.
 *   For each msgsize in {0}, {1, 2, 4, ..., maxbytes} {
 *     for reps repetitions {
 *       task 0 resets its counters then
 *       task 0 sends a msgsize byte message to task 1 then
 *       task 1 sends a msgsize byte message to task 0 then
 *       task 0 logs the msgsize as "Bytes" and
 *                   the median of elapsed_usecs/2 as "1/2 RTT (usecs)"
 *     } then
 *     task 0 computes aggregates
 *   }
 **********************************************************************/

/*****************
 * Include files *
 *****************/

/* Header files needed by all C-based backends */
#include <stdio.h>
#include <string.h>
#include <ncptl/ncptl.h>

/* Header files specific to the c_union backend */
#include "union_util.h"
#include <mpi.h>
#include <stdarg.h>

/**********
 * Macros *
 **********/

/* Define the maximum loop trip count that we're willing to unroll fully. */
#define CONC_MAX_UNROLL 5

/* Specify the minimum number of trial iterations in each FOR <time> loop. */
#define CONC_FOR_TIME_TRIALS 1

/* Define a macro that rounds a double to a ncptl_int. */
#define CONC_DBL2INT(D) ((ncptl_int)((D)+0.5))

/* Define a macro that increments a buffer pointer by a byte offset. */
#define CONC_GETBUFPTR(S) ((void *)((char *)thisev->s.S.buffer + thisev->s.S.bufferofs))

/* Implement ncptl_func_task_of in terms of ncptl_physical_to_virtual. */
#define ncptl_func_task_of(P) ((ncptl_int)(P) < 0LL || (ncptl_int)(P) >= var_num_tasks ? -1LL : ncptl_physical_to_virtual (procmap, (ncptl_int)(P)))
#define ncptl_dfunc_task_of(P) ((double) ncptl_func_task_of(P))

/* Implement ncptl_func_processor_of in terms of ncptl_virtual_to_physical. */
#define ncptl_func_processor_of(V) ((ncptl_int)(V) < 0LL || (ncptl_int)(V) >= var_num_tasks ? -1LL : ncptl_virtual_to_physical (procmap, (ncptl_int)(V)))
#define ncptl_dfunc_processor_of(V) ((double) ncptl_func_processor_of(V))

/* Define a macro that increments REDUCE's alternate buffer pointer by a byte offset. */
#define CONC_GETALTBUFPTR(S) ((void *)((char *)thisev->s.S.altbuffer + thisev->s.S.bufferofs))

/* Estimate the number of unique communicators that this program will need.
 * (The tradeoff is one of initialization time versus memory consumption.) */
#define ESTIMATED_COMMUNICATORS 128

/* Specify an operation to use for all reduction operations. */
#define REDUCE_OPERATION MPI_SUM
#define REDUCE_OPERATION_NAME "MPI_SUM"


/*********************
 * Type declarations *
 *********************/

/* Enumerate the various mechanisms used to implement MULTICAST statements. */
typedef enum {
CONC_MCAST_MPI_BCAST,       /* One to many */
CONC_MCAST_MPI_ALLTOALL,    /* Many to many, same data to all */
CONC_MCAST_MPI_ALLTOALLV,   /* General many to many */
CONC_MCAST_MPI_NUM_FUNCS    /* Number of the above */
} CONC_MCAST_MPI_FUNC;

/* Define the type of event to perform. */
typedef enum {
EV_SEND,     /* Synchronous send */
EV_ASEND,    /* Asynchronous send */
EV_RECV,     /* Synchronous receive */
EV_ARECV,    /* Asynchronous receive */
EV_WAIT,     /* Wait for all asynchronous sends/receives to complete */
EV_DELAY,    /* Spin or sleep */
EV_TOUCH,    /* Touch a region of memory */
EV_SYNC,     /* Barrier synchronization */
EV_RESET,    /* Reset counters */
EV_STORE,    /* Store all counters' current values */
EV_RESTORE,  /* Restore the previously pushed counter values */
EV_FLUSH,    /* Compute aggregate functions for log-file columns */
EV_MCAST,    /* Synchronous multicast */
EV_REDUCE,   /* Reduction with or without a subsequent multicast */
EV_BTIME,    /* Beginning of a timed loop */
EV_ETIME,    /* Ending of a timed loop */
EV_REPEAT,   /* Repeatedly process the next N events */
EV_SUPPRESS, /* Suppress writing to the log and standard output */
EV_NEWSTMT,  /* Beginning of a new top-level statement */
EV_CODE,     /* None of the above */
NUM_EVS      /* Number of event types in CONC_EVENT_TYPE */
} CONC_EVENT_TYPE;

/* Describe a synchronous or asynchronous send event. */
typedef struct {
ncptl_int dest;         /* Destination task */
ncptl_int size;         /* Number of bytes to send */
ncptl_int alignment;    /* Message alignment (in bytes) */
ncptl_int pendingsends; /* # of outstanding sends */
ncptl_int pendingrecvs; /* # of outstanding receives */
ncptl_int buffernum;    /* Buffer # to send from */
ncptl_int bufferofs;    /* Byte offset into the message buffer */
ncptl_int tag;          /* Tag to use for selective receives */
int misaligned;         /* 1=misaligned from a page; 0=align as specified */
int touching;           /* 1=touch every word before sending */
int verification;       /* 1=fill message buffer with known contents */
void *buffer;           /* Pointer to message memory */
UNION_Request * handle;   /* MPI handle representing an asynchronous send */
} CONC_SEND_EVENT;

/* Describe a synchronous or asynchronous receive event. */
typedef struct {
ncptl_int source;       /* Source task */
ncptl_int size;         /* Number of bytes to receive */
ncptl_int alignment;    /* Message alignment (in bytes) */
ncptl_int pendingsends; /* # of outstanding sends */
ncptl_int pendingrecvs; /* # of outstanding receives */
ncptl_int buffernum;    /* Buffer # to receive into */
ncptl_int bufferofs;    /* Byte offset into the message buffer */
ncptl_int tag;          /* Tag to use for selective receives */
int misaligned;         /* 1=misaligned from a page; 0=align as specified */
int touching;           /* 1=touch every word after reception */
int verification;       /* 1=verify that all bits are correct */
void *buffer;           /* Pointer to message memory */
UNION_Request * handle;   /* MPI handle representing an asynchronous receive */
} CONC_RECV_EVENT;

/* Describe a wait-for-asynchronous-completions event. */
typedef struct {
ncptl_int numsends;     /* # of sends we expect to complete. */
ncptl_int numrecvs;     /* # of receives we expect to complete. */
ncptl_int numrecvbytes; /* # of bytes we expect to receive-complete */
ncptl_int *touchedlist;    /* List of receives that need to be touched */
ncptl_int numtouches;         /* # of elements in the above */
} CONC_WAIT_EVENT;

/* Describe a spin or sleep delay. */
typedef struct {
uint64_t microseconds;  /* Length of delay in microseconds */
int spin0sleep1;        /* 0=spin; 1=sleep */
} CONC_DELAY_EVENT;

/* Describe a barrier synchronization event. */
typedef struct {
UNION_Comm communicator;   /* Set of tasks to synchronize */
} CONC_SYNC_EVENT;

/* Describe a walk over a memory-region. */
typedef struct {
ncptl_int regionbytes;  /* Size in bytes of the region to touch */
ncptl_int bytestride;   /* Stride in bytes to touch */
ncptl_int numaccesses;  /* Number of words to touch */
ncptl_int wordsize;     /* Size in bytes of each touch */
ncptl_int firstbyte;    /* Byte offset of the first byte to touch */
} CONC_TOUCH_EVENT;

/* Describe a synchronous multicast event. */
typedef struct {
ncptl_int source;       /* Source task, -1 in the many-to-many case */
ncptl_int size;         /* Number of bytes to send */
ncptl_int alignment;    /* Message alignment (in bytes) */
ncptl_int pendingsends; /* # of outstanding sends */
ncptl_int pendingrecvs; /* # of outstanding receives */
ncptl_int buffernum;    /* Buffer # to send/receive from */
ncptl_int bufferofs;    /* Byte offset into the message buffer */
ncptl_int tag;          /* Tag to use for selective receives */
int misaligned;         /* 1=misaligned from a page; 0=align as specified */
int touching;           /* 1=touch every word before sending */
int verification;       /* 1=verify that all bits are correct */
void *buffer;           /* Pointer to message memory */
ncptl_int size2;   /* Number of bytes to receive in the many-to-many case */
ncptl_int bufferofs2;   /* Byte offset into the message buffer in the many-to-many case */
void * buffer2;   /* Pointer to receive-message memory in the many-to-many case */
UNION_Comm communicator;   /* Set of tasks to multicast to/from */
int root;   /* source's rank within communicator */
int * sndvol;   /* Volume of data to send to each rank in the communicator */
int * snddisp;   /* Offset from buffer of each message to send */
int * rcvvol;   /* Volume of data to receive from each rank in the communicator */
int * rcvdisp;   /* Offset from buffer2 of each message to receive */
CONC_MCAST_MPI_FUNC mpi_func;   /* MPI function to use to perform the multicast */
} CONC_MCAST_EVENT;

/* Describe a reduction event. */
typedef struct {
ncptl_int numitems;     /* # of items to reduce */
ncptl_int itemsize;     /* # of bytes per item */
ncptl_int alignment;    /* Message alignment (in bytes) */
ncptl_int pendingsends; /* # of outstanding sends */
ncptl_int pendingrecvs; /* # of outstanding receives */
ncptl_int buffernum;    /* Buffer # to send/receive from */
ncptl_int bufferofs;    /* Byte offset into the message buffer */
ncptl_int tag;          /* Tag to use for selective receives */
int misaligned;         /* 1=misaligned from a page; 0=align as specified */
int touching;           /* 1=touch every word before sending/after receiving */
int sending;            /* 1=we're a sender */
int receiving;          /* 1=we're a receiver */
void *buffer;           /* Pointer to message memory */
void * altbuffer;   /* Pointer to additional message memory */
UNION_Comm sendcomm;   /* Set of tasks to reduce from */
UNION_Comm recvcomm;   /* Set of tasks to reduce to */
UNION_Datatype datatype;   /* MPI datatype to reduce */
int reducetype;   /* 0=reduce; 1=allreduce; 2=reduce+bcast */
ncptl_int reduceroot;   /* Root task of the reduction if reducetype is 0 or 2 */
ncptl_int bcastroot;   /* Root task of the multicast if reducetype is 2 */
} CONC_REDUCE_EVENT;

/* Describe an event representing the beginning of a timed loop. */
typedef struct {
uint64_t usecs;         /* Requested loop duration */
uint64_t warmup_usecs;  /* Requested duration of warmup loops */
uint64_t starttime;     /* Time at which the loop state last changed */
uint64_t itersleft;     /* # of iterations remaining */
uint64_t previters;     /* # of iterations we performed last time */
int prev_quiet;         /* Previous value of suppress_output */
int timing_trial;       /* 1=performing a timing trial; 0=running for real */
volatile int finished;  /* 1=time has expired; 0=still ticking */
} CONC_BTIME_EVENT;

/* Describe an event representing the end of a timed loop. */
typedef struct {
ncptl_int begin_event;  /* Index into eventlist[] of the corresponding BTIME event */
} CONC_ETIME_EVENT;

/* Describe an event representing repetitions of subsequent events. */
typedef struct {
ncptl_int end_event;    /* Index into eventlist[] of the last event to repeat */
ncptl_int numreps;      /* # of repetitions to perform */
} CONC_REPEAT_EVENT;

/* Describe an event representing output suppression (either on or off). */
typedef struct conc_suppress_event {
int quiet;              /* 0=allow output; 1=suppress it */
int prev_quiet;         /* Previous value of suppress_output */
ncptl_int matching_event;  /* Event ID of the "suppression on" event */
uint64_t stop_elapsed_usecs;   /* Time at which we suppressed output */
} CONC_SUPPRESS_EVENT;

/* Describe an event representing arbitrary code to execute at run time. */
typedef struct {
ncptl_int number;       /* Unique number corresponding to a specific piece of code */NCPTL_VIRT_PHYS_MAP *procmap;  /* Current mapping between tasks and processors */
ncptl_int var_msgsize;   /* Copy of var_msgsize to use within a piece of code */
} CONC_CODE_EVENT;

/* Describe an arbitrary coNCePTuaL event. */
typedef struct {
CONC_EVENT_TYPE type;          /* Type of event */
union {
CONC_SEND_EVENT send;          /* Send state */
CONC_RECV_EVENT recv;          /* Receive state */
CONC_WAIT_EVENT wait;          /* Wait-for-completions state */
CONC_DELAY_EVENT delay;        /* State for spins and sleeps */
CONC_TOUCH_EVENT touch;        /* State for memory touching */
CONC_SYNC_EVENT sync;          /* Synchronization state */
CONC_MCAST_EVENT mcast;        /* Multicast state */
CONC_REDUCE_EVENT reduce;      /* Reduction state */
CONC_BTIME_EVENT btime;        /* Timed-loop state */
CONC_ETIME_EVENT etime;        /* Additional timed-loop state */
CONC_REPEAT_EVENT rep;         /* Repeated-events state */
CONC_SUPPRESS_EVENT suppress;  /* State for suppressing output */
CONC_CODE_EVENT code;          /* State for arbitrary code */
} s;
} CONC_EVENT;

/* Fully specify an arbitrary for() loop (used by FOR EACH). */
typedef struct {
NCPTL_QUEUE *list_comp;  /* NULL=ordinary list; other=list comprehension values */
int integral;        /* 1=integral values; 0=floating-point values */
enum {               /* Comparison of loop variable to end variable */
CONC_LEQ,                /* Increasing progression */
CONC_GEQ                 /* Decreasing progression */
} comparator;
enum {               /* How to increment the loop variable */
CONC_ADD,                /* Arithmetically */
CONC_MULT,               /* Geometrically increasing */
CONC_DIV                 /* Geometrically decreasing */
} increment;
union {
struct {
ncptl_int loopvar;   /* Loop variable */
ncptl_int prev_loopvar; /* Previous value of loop variable */
ncptl_int startval;  /* Initial value of loop variable */
ncptl_int endval;    /* Value not to exceed */
ncptl_int incval;    /* Loop-variable increment */
} i;
struct {
double loopvar;      /* Loop variable */
double prev_loopvar; /* Previous value of loop variable */
double startval;     /* Initial value of loop variable */
double endval;       /* Value not to exceed */
double incval;       /* Loop-variable increment */
} d;
} u;
} LOOPBOUNDS;

/********************
 * Global variables *
 ********************/

/* Variables exported to coNCePTuaL programs */
static ncptl_int var_bytes_received = 0;   /* Total number of bytes received */
static ncptl_int var_msgs_received = 0;   /* Total number of messages received */
static ncptl_int var_bit_errors = 0;   /* Total number of bit errors observed */
static ncptl_int var_total_msgs = 0;   /* Sum of messages sent and messages received */
static ncptl_int var_msgs_sent = 0;   /* Total number of messages sent */
static ncptl_int var_bytes_sent = 0;   /* Total number of bytes sent */
static ncptl_int var_num_tasks = 1;   /* Number of tasks running the program */
static ncptl_int var_elapsed_usecs = 0;   /* Elapsed time in microseconds */
static ncptl_int var_total_bytes = 0;   /* Sum of bytes sent and bytes received */

/* Dummy variable to help mark other variables as used */
static union {
ncptl_int ni;
int i;
void *vp;
} conc_dummy_var;

/* Variables used internally by boilerplate code */
static uint64_t starttime;   /* Time the clock was last reset (microseconds) */
static ncptl_int pendingrecvs = 0;   /* Current # of outstanding receives */
static ncptl_int pendingrecvbytes = 0; /* Current # of bytes in outstanding receives */
static NCPTL_QUEUE *touchedqueue;      /* Queue of asynchronous receives to touch */
static ncptl_int pendingsends = 0;   /* Current # of outstanding sends */
static NCPTL_QUEUE *eventqueue;   /* List of coNCePTuaL events to perform */
static int within_time_loop = 0;   /* 1=we're within a FOR <time> loop */
static int suppress_output = 1;    /* 1=suppress output to stdout and the log file */
static void *touch_region = NULL;   /* Memory region to touch */
static ncptl_int touch_region_size = 0;   /* # of bytes in the above */
static int virtrank;    /* This task's virtual rank in the computation */
static int physrank;    /* This task's physical rank in the computation */
static NCPTL_VIRT_PHYS_MAP *procmap;  /* Virtual to physical rank mapping */
static NCPTL_LOG_FILE_STATE *logstate;   /* Opaque object representing all log-file state */
static char *logfiletmpl;   /* Template for the log file's name */

/* Global variables specific to the c_union backend */
static ncptl_int mpi_is_running = 0;   /* 1=MPI has been initialized */
static NCPTL_QUEUE * recvreqQ;   /* List of MPI receive requests */
static UNION_Request * recvrequests;   /* List version of recvreqQ */
static NCPTL_QUEUE * recvstatQ;   /* List of MPI receive statuses */
static UNION_Status * recvstatuses;   /* List version of recvstatQ */
static NCPTL_QUEUE * sendreqQ;   /* List of MPI send requests */
static UNION_Request * sendrequests;   /* List version of sendreqQ */
static NCPTL_QUEUE * sendstatQ;   /* List of MPI send statuses */
static UNION_Status * sendstatuses;   /* List version of sendstatQ */
static NCPTL_SET * communicators;   /* Map from an array of processor flags to an MPI communicator */
static MPI_Errhandler mpi_error_handler;   /* Handle to handle_MPI_error() */
static ncptl_int mpi_tag_ub;   /* Upper bound on an MPI tag value */
static ncptl_int conc_mcast_tallies[CONC_MCAST_MPI_NUM_FUNCS] = {0};   /* Tallies of (static) multicast implementation functions */

/* Program-specific variables */
static ncptl_int var_reps;   /* Number of repetitions of each message size (command-line argument) */
static ncptl_int var_maxbytes;   /* Maximum number of bytes to transmit (command-line argument) */

/*************************
 * Function declarations *
 *************************/

/* Capture MPI errors. */
static void handle_MPI_error (UNION_Comm *comm, int *errcode, ...)
{
va_list args;
char errstring[MPI_MAX_ERROR_STRING];
int errstrlen;

va_start (args, errcode);
if (MPI_Error_string (*errcode, errstring, &errstrlen) == MPI_SUCCESS)
fprintf(stderr, "MPI run-time error: %s", errstring);
else
fprintf(stderr, "MPI aborted with unrecognized error code %d", *errcode);
conc_dummy_var.vp = (void *) comm;   /* Prevent the compiler from complaining that comm is unused. */
va_end (args);
}

/* Perform the equivalent of MPI_Comm_rank() for an arbitrary process. */
static int rank_in_MPI_communicator (UNION_Comm subcomm, int global_rank)
{
  MPI_Group world_group;   /* Group associated with MPI_COMM_WORLD */
  MPI_Group subgroup;      /* Group associate with subcomm */
  int subrank;             /* global_rank's rank within subcomm */

  MPI_Comm_group (MPI_COMM_WORLD, &world_group);
  MPI_Comm_group (subcomm, &subgroup);
  MPI_Group_translate_ranks (world_group, 1, &global_rank, subgroup, &subrank);
  return subrank;
}

/* Map an arbitrary tag to within MPI's valid range of [0, mpi_tag_ub]. */
static ncptl_int map_tag_into_MPI_range (ncptl_int tag)
{
if (tag == NCPTL_INT_MIN)
 /* Avoid taking the absolute value of NCPTL_INT_MIN. */
tag = 555666773LL;   /* Arbitrary value */
tag = ncptl_func_abs (tag);   /* Only nonnegatives values are allowed. */
if (mpi_tag_ub < NCPTL_INT_MAX)
tag %= mpi_tag_ub + 1;
return tag;
}

/* Given an array of task in/out booleans return an MPI
 * communicator that represents the "in" tasks. */
static UNION_Comm define_MPI_communicator (char *procflags)
{
UNION_Comm *existing_comm;    /* Previously defined MPI communicator */
UNION_Comm new_comm;          /* Newly defined MPI communicator */

existing_comm = (UNION_Comm *) ncptl_set_find (communicators, (void *)procflags);
if (existing_comm)
return *existing_comm;
(void) MPI_Comm_split (MPI_COMM_WORLD, (int)procflags[physrank], physrank, &new_comm);
(void) MPI_Errhandler_set (new_comm, mpi_error_handler);
ncptl_set_insert (communicators, (void *)procflags, (void *)&new_comm);
return define_MPI_communicator (procflags);
}

/* Return 1 if a sequence loop will take at least one trip. */
static int conc_seq_nonempty (LOOPBOUNDS *seq)
{
ncptl_int startval;   /* Integer version of seq's startval element */
ncptl_int endval;   /* Integer version of seq's endval element */

if (seq->integral) {
startval = seq->u.i.startval;
endval = seq->u.i.endval;
}
else {
startval = CONC_DBL2INT (seq->u.d.startval);
endval = CONC_DBL2INT (seq->u.d.endval);
}
switch (seq->comparator) {
case CONC_LEQ:
return startval <= endval;

case CONC_GEQ:
return startval >= endval;

default:
ncptl_fatal ("Internal error -- unknown comparator");
}
return -1;     /* Appease idiotic compilers. */
}

/* Initialize a sequence loop. */
static void conc_seq_init (LOOPBOUNDS *seq)
{
if (seq->integral) {
seq->u.i.loopvar = seq->u.i.startval;
seq->u.i.prev_loopvar = seq->u.i.loopvar - 1;
}
else {
seq->u.d.loopvar = seq->u.d.startval;
seq->u.d.prev_loopvar = seq->u.d.loopvar - 1.0;
}
}

/* Return 1 if a sequence loop should continue, 0 when finished. */
static int conc_seq_continue (LOOPBOUNDS *seq)
{
LOOPBOUNDS seq_int;   /* Integer equivalent of *seq */
if (seq->integral)
seq_int = *seq;
else {
seq_int.u.i.loopvar = CONC_DBL2INT (seq->u.d.loopvar);
seq_int.u.i.prev_loopvar = CONC_DBL2INT (seq->u.d.prev_loopvar);
seq_int.u.i.endval = CONC_DBL2INT (seq->u.d.endval);
}

if (seq_int.u.i.loopvar == seq_int.u.i.prev_loopvar)
return 0;
switch (seq->comparator) {
case CONC_LEQ:
return seq_int.u.i.loopvar <= seq_int.u.i.endval;

case CONC_GEQ:
return seq_int.u.i.loopvar >= seq_int.u.i.endval;

default:
ncptl_fatal ("Internal error -- unknown comparator");
}
return -1;     /* Appease idiotic compilers. */
}

/* Proceed to the next iteration of a sequence loop. */
static void conc_seq_next (LOOPBOUNDS *seq)
{
if (seq->integral) {
seq->u.i.prev_loopvar = seq->u.i.loopvar;
switch (seq->increment) {
case CONC_ADD:
seq->u.i.loopvar += seq->u.i.incval;
break;

case CONC_MULT:
seq->u.i.loopvar *= seq->u.i.incval;
break;

case CONC_DIV:
seq->u.i.loopvar /= seq->u.i.incval;
break;

default:
ncptl_fatal ("Internal error -- unknown incrementer");
}
}
else {
seq->u.d.prev_loopvar = seq->u.d.loopvar;
switch (seq->increment) {
case CONC_ADD:
seq->u.d.loopvar += seq->u.d.incval;
break;

case CONC_MULT:
seq->u.d.loopvar *= seq->u.d.incval;
break;

case CONC_DIV:
seq->u.d.loopvar /= seq->u.d.incval;
break;

default:
ncptl_fatal ("Internal error -- unknown incrementer");
}
}
}

/* Inhibit the compiler from complaining that
 * certain variables are defined but not used.
 * This function should never be called. */
static void conc_mark_variables_used (void)
{
conc_dummy_var.ni = var_bytes_received;
conc_dummy_var.ni = var_msgs_received;
conc_dummy_var.ni = var_bit_errors;
conc_dummy_var.ni = var_total_msgs;
conc_dummy_var.ni = var_msgs_sent;
conc_dummy_var.ni = var_bytes_sent;
conc_dummy_var.ni = var_num_tasks;
conc_dummy_var.ni = var_elapsed_usecs;
conc_dummy_var.ni = var_total_bytes;
conc_dummy_var.ni = pendingrecvbytes;
conc_dummy_var.ni = touch_region_size;
conc_dummy_var.vp = touch_region;
conc_dummy_var.i  = within_time_loop;
conc_dummy_var.i  = suppress_output;
rank_in_MPI_communicator (MPI_COMM_WORLD, 0);
}

/* Allocate a new event of a given type and return a pointer to it. */
static CONC_EVENT *conc_allocate_event (CONC_EVENT_TYPE type)
{
CONC_EVENT *newevent = (CONC_EVENT *) ncptl_queue_allocate (eventqueue);

newevent->type = type;
return newevent;
}

/* Declare an exit handler that gets called automatically when the
 * program terminates, whether successfully or not. */
static void conc_exit_handler (void)
{
if (mpi_is_running)
MPI_Abort (MPI_COMM_WORLD, 1);
}


/* Initialize coNCePTuaL, the messaging layer, and this program itself. */
static void conc_initialize (int argc, char *argv[])
{
 /* Variables needed by all C-based backends */
CONC_EVENT * eventlist;   /* List of events to execute */
ncptl_int numevents;   /* Number of entries in eventlist[] */
int help_only = 0;   /* 1=User specified --help; save time by skipping ncptl_init() */
char * argv0 = strrchr(argv[0], '/') ? strrchr(argv[0], '/')+1 : argv[0];   /* Base name of the executable program */
int i;   /* Generic loop variable */

 /* Declare all of our command-line arguments. */
NCPTL_CMDLINE arguments[] = {
{ NCPTL_TYPE_STRING, NULL, "logfile", 'L', "Log-file template", {0}},
{ NCPTL_TYPE_INT, NULL, "reps", 'r', "Number of repetitions of each message size", {0}},
{ NCPTL_TYPE_INT, NULL, "maxbytes", 'm', "Maximum number of bytes to transmit", {0}}
};

 /* Incorporate the complete coNCePTuaL source code as an array
  * for use by ncptl_log_write_prologue(). */
char *sourcecode[] = {
"# A ping-pong latency test written in coNCePTuaL",
"",
"Require language version \"1.5\".",
"",
"# Parse the command line.",
"reps is \"Number of repetitions of each message size\" and comes from",
" \"--reps\" or \"-r\" with default 1000.",
"maxbytes is \"Maximum number of bytes to transmit\" and comes from",
" \"--maxbytes\" or \"-m\" with default 1M.",
"",
"# Ensure that we have a peer with whom to communicate.",
"Assert that \"the latency test requires at least two tasks\" with num_tasks>=2.",
"",
"# Perform the benchmark.",
"For each msgsize in {0}, {1, 2, 4, ..., maxbytes} {",
"  for reps repetitions {",
"    task 0 resets its counters then",
"    task 0 sends a msgsize byte message to task 1 then",
"    task 1 sends a msgsize byte message to task 0 then",
"    task 0 logs the msgsize as \"Bytes\" and",
"                the median of elapsed_usecs/2 as \"1/2 RTT (usecs)\"",
"  } then",
"  task 0 computes aggregates",
"}",
NULL
};

 /* Variables specific to the c_union backend */
int num_tasks;   /* int version of var_num_tasks needed by UNION_UNION_Comm_size() */
char * procflags;   /* Array of 1s representing an all-task MPI communicator */
UNION_Comm comm_world = MPI_COMM_WORLD;   /* Copy of MPI_COMM_WORLD that we can take the address of */
void * attr_val;   /* Pointed to the value of MPI_TAG_UB */
int attr_flag = 0;   /* true=MPI_TAG_UB was extracted; false=not extracted */

 /* As a special case, if the command line contains --help, then skip
  * the coNCePTuaL initialization step. */
for (i=1; i<argc; i++)
if (!strcmp(argv[i], "--"))
break;
else
if (!strcmp(argv[i], "--help") || !strcmp(argv[i], "-?")) {
argv[1] = "-?";   /* Guaranteed to work, even with getopt() */
help_only = 1;
break;
}

 /* Perform various initializations specific to the c_union backend. */
 /* Initialize MPI. */
//(void) MPI_Init(&argc, &argv);
mpi_is_running = 1;

 /* Initialize the coNCePTuaL run-time library. */
if (!help_only)
ncptl_init (NCPTL_RUN_TIME_VERSION, argv[0]);
(void) atexit (conc_exit_handler);

 /* Initialize the communication routines needed by the c_union backend. */
//(void) MPI_Errhandler_create ((MPI_Handler_function *)handle_MPI_error, &mpi_error_handler);
//(void) MPI_Errhandler_set (MPI_COMM_WORLD, mpi_error_handler);
(void) UNION_MPI_Comm_rank(MPI_COMM_WORLD, &physrank);
(void) UNION_MPI_Comm_size(MPI_COMM_WORLD, &num_tasks);
var_num_tasks = (ncptl_int) num_tasks;
(void) MPI_Comm_get_attr(MPI_COMM_WORLD, MPI_TAG_UB, &attr_val, &attr_flag);
mpi_tag_ub = (ncptl_int) (attr_flag ? *(int *)attr_val : 32767);

 /* Plug variables and default values into the NCPTL_CMDLINE structure. */
arguments[0].variable = (CMDLINE_VALUE *) &logfiletmpl;
arguments[1].variable = (CMDLINE_VALUE *) &var_reps;
arguments[1].defaultvalue.intval = 1000LL;
arguments[2].variable = (CMDLINE_VALUE *) &var_maxbytes;
arguments[2].defaultvalue.intval = 1048576LL;

 /* Parse the command line. */
mpi_is_running = 0;   /* Don't invoke MPI_Abort() after --help. */
ncptl_parse_command_line (argc, argv, arguments, sizeof(arguments)/sizeof(NCPTL_CMDLINE));
if (help_only)
ncptl_fatal ("Internal error in the c_generic backend: failed to exit after giving help");
mpi_is_running = 1;

 /* Establish a mapping from (virtual) task IDs to (physical) ranks. */
procmap = ncptl_allocate_task_map (var_num_tasks);
virtrank = ncptl_physical_to_virtual (procmap, physrank);

 /* Allocate a variety of dynamically growing queues. */
eventqueue = ncptl_queue_init (sizeof (CONC_EVENT));
touchedqueue = ncptl_queue_init (sizeof (ncptl_int));

 /* Perform initializations specific to the c_union backend. */
sendreqQ = ncptl_queue_init (sizeof (UNION_Request));
sendstatQ = ncptl_queue_init (sizeof (UNION_Status));
recvreqQ = ncptl_queue_init (sizeof (UNION_Request));
recvstatQ = ncptl_queue_init (sizeof (UNION_Status));
communicators = ncptl_set_init (ESTIMATED_COMMUNICATORS, var_num_tasks*sizeof(char), sizeof(UNION_Comm));
procflags = (char *) ncptl_malloc (var_num_tasks*sizeof(char), 0);
for (i=0; i<var_num_tasks; i++)
procflags[i] = 1;
ncptl_set_insert (communicators, (void *)procflags, (void *)&comm_world);
ncptl_free (procflags);

 /****************************************************
  * Generated, program-specific initialization code. *
  ****************************************************/

 /* ASSERT THAT the latency test requires at least two tasks. */
if (!((var_num_tasks)>=(2LL)))
ncptl_fatal ("Assertion failure: the latency test requires at least two tasks");
 /* FOR EACH var_msgsize IN [(['0LL'], None), (['1LL', '2LL', '4LL'], 'var_maxbytes')]... */
{
LOOPBOUNDS loopbounds[2];   /* List of range descriptions */
ncptl_int rangenum;   /* Current offset into loopbounds[] */
ncptl_int initial_vals[3];   /* Cache of the initial, enumerated values */
ncptl_int final_val;   /* Cache of the final value */

 /* Write range 0's loop bounds, "next" function, and termination function to loopbounds[0]. */
loopbounds[0].list_comp = NULL;
initial_vals[0] = 0LL;
final_val = 0LL;
loopbounds[0].integral = 1;
loopbounds[0].u.i.startval = initial_vals[0];
loopbounds[0].u.i.endval = final_val;
loopbounds[0].comparator = CONC_LEQ;
loopbounds[0].increment = CONC_ADD;
loopbounds[0].u.i.incval = 1LL;

 /* Write range 1's loop bounds, "next" function, and termination function to loopbounds[1]. */
loopbounds[1].list_comp = NULL;
initial_vals[0] = 1LL;
initial_vals[1] = 2LL;
initial_vals[2] = 4LL;
final_val = var_maxbytes;
loopbounds[1].integral = 1;
loopbounds[1].u.i.startval = initial_vals[0];
loopbounds[1].u.i.endval = final_val;
if (initial_vals[1]-initial_vals[0]==initial_vals[2]-initial_vals[1]) {
 /* Arithmetic progression */
loopbounds[1].comparator = initial_vals[0]<=initial_vals[1] ? CONC_LEQ : CONC_GEQ;
loopbounds[1].increment = CONC_ADD;
loopbounds[1].u.i.incval = initial_vals[1]-initial_vals[0];
if (!loopbounds[1].u.i.incval)
loopbounds[1].u.i.incval = 1LL;   /* Handle {x,x,x,...,x} case (constant value) */
}
else
if (initial_vals[0] && initial_vals[1] && initial_vals[0]<initial_vals[1] && initial_vals[0]*(initial_vals[1]/initial_vals[0])==initial_vals[1] && initial_vals[1]*(initial_vals[2]/initial_vals[1])==initial_vals[2] && initial_vals[1]/initial_vals[0]==initial_vals[2]/initial_vals[1]) {
 /* Geometric progression (increasing, integral multiplier) */
loopbounds[1].comparator = CONC_LEQ;
loopbounds[1].increment = CONC_MULT;
loopbounds[1].u.i.incval = initial_vals[1]/initial_vals[0];
}
else
if (initial_vals[1] && initial_vals[2] && initial_vals[0]>initial_vals[1] && initial_vals[1]*(initial_vals[0]/initial_vals[1])==initial_vals[0] && initial_vals[2]*(initial_vals[1]/initial_vals[2])==initial_vals[1] && initial_vals[0]/initial_vals[1]==initial_vals[1]/initial_vals[2]) {
 /* Geometric progression (decreasing, integral multiplier) */
loopbounds[1].comparator = CONC_GEQ;
loopbounds[1].increment = CONC_DIV;
loopbounds[1].u.i.incval = initial_vals[0]/initial_vals[1];
}
else
if (initial_vals[0] && initial_vals[1]) {
double initial_vals_d[3];   /* Cache of the initial, enumerated values, but in floating-point context */
double avg_factor;   /* Average multiplier for terms in the sequence */
initial_vals_d[0] = 1.0;
initial_vals_d[1] = 2.0;
initial_vals_d[2] = 4.0;
avg_factor = (initial_vals_d[1]/initial_vals_d[0] + initial_vals_d[2]/initial_vals_d[1]) / 2.0;
if (CONC_DBL2INT(initial_vals_d[0]*avg_factor)==initial_vals[1] && CONC_DBL2INT(initial_vals_d[1]*avg_factor)==initial_vals[2]) {
 /* Geometric progression (decreasing or non-integral multiplier) */
loopbounds[1].comparator = initial_vals[0]<initial_vals[1] ? CONC_LEQ : CONC_GEQ;
loopbounds[1].integral = 0;
loopbounds[1].increment = CONC_MULT;
loopbounds[1].u.d.startval = initial_vals_d[0];
loopbounds[1].u.d.endval = (double)var_maxbytes;
loopbounds[1].u.d.incval = avg_factor;
}
else
ncptl_fatal ("Unable to find an arithmetic or geometric pattern to {%" NICS ", %" NICS ", %" NICS ", ..., %" NICS "}", initial_vals[0], initial_vals[1], initial_vals[2], final_val);
}
else
ncptl_fatal ("Unable to find an arithmetic or geometric pattern to {%" NICS ", %" NICS ", %" NICS ", ..., %" NICS "}", initial_vals[0], initial_vals[1], initial_vals[2], final_val);

 /* Now that we've defined all of our ranges we iterate over each range
  * and each element within each range. */
for (rangenum=0LL; rangenum<2; rangenum++) {
LOOPBOUNDS * thisrange = &loopbounds[rangenum];   /* Current range */
if (conc_seq_nonempty (thisrange))
for (conc_seq_init (thisrange);
conc_seq_continue (thisrange);
conc_seq_next (thisrange)) {
ncptl_int var_msgsize;
if (thisrange->list_comp == NULL)
 /* The loopvar field contains the value for var_msgsize. */
var_msgsize = thisrange->integral ? thisrange->u.i.loopvar : CONC_DBL2INT(thisrange->u.d.loopvar);
else
 /* The queue of list-comprehension values provides the value for var_msgsize. */
var_msgsize = *(ncptl_int *)ncptl_queue_pop(thisrange->list_comp);
{
 /* FOR var_reps REPETITIONS... */
{
ncptl_int numreps = var_reps;   /* Total # of repetitions to perform */
int unroll_loop = numreps <= CONC_MAX_UNROLL;   /* 1=unroll loop; 0=use a REPEAT event */
ncptl_int repnum;   /* Current repetition number */
CONC_EVENT * repevent = NULL;   /* Event designating repetition */
ncptl_int repeventnum = -1LL;   /* Event number corresponding to repevent */
 /* Conditionally unroll the loop. */
for (repnum=0; repnum<(unroll_loop?numreps:1); repnum++) {
 /* Allocate a repeat event if we have more than one repetition. */
if (!unroll_loop && numreps > 1LL) {
repeventnum = ncptl_queue_length (eventqueue);
repevent =  conc_allocate_event (EV_REPEAT);
repevent->s.rep.numreps = numreps;
}

 /* Output a loop body if we have at least one repetition. */
if (unroll_loop || numreps > 0LL) {
 /* TASK 0LL RESET THEIR COUNTERS */
if ((0LL) == virtrank) {   /* TASK 0LL */
 /* The current coNCePTuaL statement applies to our task. */
(void) conc_allocate_event (EV_RESET);
}
 /* THEN... */
 /* TASK 0LL RECEIVES FROM TASK 1LL */
if ((0LL)>=0 && (0LL)<var_num_tasks) {
 /* 0LL now represents one of the tasks that will send to us. */
ncptl_int ivar_a_task = 0LL;
if (virtrank == (1LL)) {
 /* In this scope, we must be a message recipient. */
 /* Prepare to receive 1LL messages. */
ncptl_int numreps = 1LL;   /* Number of messages */
if (numreps > 1LL) {
CONC_EVENT * repeatev;   /* Event specifying the number of repetitions to perform */
repeatev = conc_allocate_event (EV_REPEAT);
repeatev->s.rep.end_event = ncptl_queue_length(eventqueue);
repeatev->s.rep.numreps = numreps;
}

 /* Ensure we have at least one message to receive. */
if (numreps > 0LL) {
CONC_EVENT *thisev = conc_allocate_event (EV_RECV);

 /* Fill in all of the fields of a receive-event structure. */
thisev->s.recv.source = ncptl_virtual_to_physical (procmap, ivar_a_task);
thisev->s.recv.size = var_msgsize;
thisev->s.recv.alignment = 0LL;
thisev->s.recv.misaligned = 0;
thisev->s.recv.touching = 0;
thisev->s.recv.verification = 0;
thisev->s.recv.tag = 0LL;
thisev->s.recv.pendingsends = pendingsends;
thisev->s.recv.pendingrecvs = pendingrecvs;
thisev->s.recv.bufferofs = 0LL;
thisev->s.recv.buffernum = thisev->s.recv.verification ? pendingsends+pendingrecvs : 0;
//(void) ncptl_malloc_message (thisev->s.recv.size+thisev->s.recv.bufferofs, thisev->s.recv.alignment, thisev->s.recv.buffernum, thisev->s.recv.misaligned);
thisev->s.recv.buffer = NULL;
thisev->s.recv.tag = map_tag_into_MPI_range (thisev->s.recv.tag);
}
}
}
 /* TASK 0LL SENDS TO TASK 1LL */
if ((0LL) == virtrank) {   /* TASK 0LL */
 /* The current coNCePTuaL statement applies to our task. */
ncptl_int virtdest = 1LL;
if (virtdest>=0 && virtdest<var_num_tasks) {
 /* In this scope, 1LL represents a single receiver. */
 /* Prepare to send 1LL messages. */
ncptl_int numreps = 1LL;   /* Number of messages */
if (numreps > 1LL) {
CONC_EVENT * repeatev;   /* Event specifying the number of repetitions to perform */
repeatev = conc_allocate_event (EV_REPEAT);
repeatev->s.rep.end_event = ncptl_queue_length(eventqueue);
repeatev->s.rep.numreps = numreps;
}

 /* Ensure we have at least one message to send. */
if (numreps > 0LL) {
CONC_EVENT *thisev = conc_allocate_event (EV_SEND);
if (virtrank == (1LL))
ncptl_fatal ("Send-to-self deadlock encountered on task %d in line 18 of the source code", virtrank);

 /* Fill in all of the fields of a send-event structure. */
thisev->s.send.dest = ncptl_virtual_to_physical (procmap, 1LL);
thisev->s.send.size = var_msgsize;
thisev->s.send.alignment = 0LL;
thisev->s.send.misaligned = 0;
thisev->s.send.touching = 0;
thisev->s.send.verification = 0;
thisev->s.send.tag = 0LL;
thisev->s.send.pendingsends = pendingsends;
thisev->s.send.pendingrecvs = pendingrecvs;
thisev->s.send.bufferofs = 0LL;
thisev->s.send.buffernum = thisev->s.send.verification ? pendingsends+pendingrecvs : 0;
//(void) ncptl_malloc_message (thisev->s.send.size+thisev->s.send.bufferofs, thisev->s.send.alignment, thisev->s.send.buffernum, thisev->s.send.misaligned);
thisev->s.send.buffer = NULL;
thisev->s.send.tag = map_tag_into_MPI_range (thisev->s.send.tag);
}
}
}
 /* THEN... */
 /* TASK 1LL RECEIVES FROM TASK 0LL */
if ((1LL)>=0 && (1LL)<var_num_tasks) {
 /* 1LL now represents one of the tasks that will send to us. */
ncptl_int ivar_b_task = 1LL;
if (virtrank == (0LL)) {
 /* In this scope, we must be a message recipient. */
 /* Prepare to receive 1LL messages. */
ncptl_int numreps = 1LL;   /* Number of messages */
if (numreps > 1LL) {
CONC_EVENT * repeatev;   /* Event specifying the number of repetitions to perform */
repeatev = conc_allocate_event (EV_REPEAT);
repeatev->s.rep.end_event = ncptl_queue_length(eventqueue);
repeatev->s.rep.numreps = numreps;
}

 /* Ensure we have at least one message to receive. */
if (numreps > 0LL) {
CONC_EVENT *thisev = conc_allocate_event (EV_RECV);

 /* Fill in all of the fields of a receive-event structure. */
thisev->s.recv.source = ncptl_virtual_to_physical (procmap, ivar_b_task);
thisev->s.recv.size = var_msgsize;
thisev->s.recv.alignment = 0LL;
thisev->s.recv.misaligned = 0;
thisev->s.recv.touching = 0;
thisev->s.recv.verification = 0;
thisev->s.recv.tag = 0LL;
thisev->s.recv.pendingsends = pendingsends;
thisev->s.recv.pendingrecvs = pendingrecvs;
thisev->s.recv.bufferofs = 0LL;
thisev->s.recv.buffernum = thisev->s.recv.verification ? pendingsends+pendingrecvs : 0;
//(void) ncptl_malloc_message (thisev->s.recv.size+thisev->s.recv.bufferofs, thisev->s.recv.alignment, thisev->s.recv.buffernum, thisev->s.recv.misaligned);
thisev->s.recv.buffer = NULL;
thisev->s.recv.tag = map_tag_into_MPI_range (thisev->s.recv.tag);
}
}
}
 /* TASK 1LL SENDS TO TASK 0LL */
if ((1LL) == virtrank) {   /* TASK 1LL */
 /* The current coNCePTuaL statement applies to our task. */
ncptl_int virtdest = 0LL;
if (virtdest>=0 && virtdest<var_num_tasks) {
 /* In this scope, 0LL represents a single receiver. */
 /* Prepare to send 1LL messages. */
ncptl_int numreps = 1LL;   /* Number of messages */
if (numreps > 1LL) {
CONC_EVENT * repeatev;   /* Event specifying the number of repetitions to perform */
repeatev = conc_allocate_event (EV_REPEAT);
repeatev->s.rep.end_event = ncptl_queue_length(eventqueue);
repeatev->s.rep.numreps = numreps;
}

 /* Ensure we have at least one message to send. */
if (numreps > 0LL) {
CONC_EVENT *thisev = conc_allocate_event (EV_SEND);
if (virtrank == (0LL))
ncptl_fatal ("Send-to-self deadlock encountered on task %d in line 19 of the source code", virtrank);

 /* Fill in all of the fields of a send-event structure. */
thisev->s.send.dest = ncptl_virtual_to_physical (procmap, 0LL);
thisev->s.send.size = var_msgsize;
thisev->s.send.alignment = 0LL;
thisev->s.send.misaligned = 0;
thisev->s.send.touching = 0;
thisev->s.send.verification = 0;
thisev->s.send.tag = 0LL;
thisev->s.send.pendingsends = pendingsends;
thisev->s.send.pendingrecvs = pendingrecvs;
thisev->s.send.bufferofs = 0LL;
thisev->s.send.buffernum = thisev->s.send.verification ? pendingsends+pendingrecvs : 0;
//(void) ncptl_malloc_message (thisev->s.send.size+thisev->s.send.bufferofs, thisev->s.send.alignment, thisev->s.send.buffernum, thisev->s.send.misaligned);
thisev->s.send.buffer = NULL;
thisev->s.send.tag = map_tag_into_MPI_range (thisev->s.send.tag);
}
}
}
 /* THEN... */
 /* TASK 0LL LOGS "Bytes" AND "1/2 RTT (usecs)" */
if ((0LL) == virtrank) {   /* TASK 0LL */
 /* The current coNCePTuaL statement applies to our task. */
CONC_EVENT *thisev = conc_allocate_event (EV_CODE);
thisev->s.code.number = 0;
thisev->s.code.procmap = NULL;
thisev->s.code.var_msgsize = var_msgsize;
}
}
}

 /* Assign the number of events to repeat, now that we know that number. */
if (!unroll_loop && numreps > 1LL) {
repevent = repeventnum + (CONC_EVENT *) ncptl_queue_contents (eventqueue, 0);
repevent->s.rep.end_event = ncptl_queue_length (eventqueue) - 1;
}
}
 /* THEN... */
 /* TASK 0LL COMPUTES AGGREGATES */
if ((0LL) == virtrank) {   /* TASK 0LL */
 /* The current coNCePTuaL statement applies to our task. */
(void) conc_allocate_event (EV_FLUSH);
}
}
}
}
}

 /*************************
  * More boilerplate code *
  *************************/

 /* Abort if the program will terminate with pending messages. */
if (pendingsends && pendingrecvs)
ncptl_fatal("Neglected to await the completion of %" NICS " asynchronous %s and %" NICS " asynchronous %s",
pendingsends, pendingsends==1LL ? "send" : "sends",
pendingrecvs, pendingrecvs==1LL ? "receive" : "receives");
else
if (pendingsends)
ncptl_fatal("Neglected to await the completion of %" NICS " asynchronous %s",
pendingsends, pendingsends==1LL ? "send" : "sends");
else
if (pendingrecvs)
ncptl_fatal("Neglected to await the completion of %" NICS " asynchronous %s",
pendingrecvs, pendingrecvs==1LL ? "receive" : "receives");

 /* Allocate memory for non-unique messages and asynchronous
  * message handles now that we know how much memory we need
  * to allocate. */
eventlist = (CONC_EVENT *) ncptl_queue_contents (eventqueue, 0);
numevents = ncptl_queue_length (eventqueue);
sendrequests = (UNION_Request *) ncptl_queue_contents (sendreqQ, 0);
recvrequests = (UNION_Request *) ncptl_queue_contents (recvreqQ, 0);
for (i=0; i<numevents; i++) {
CONC_EVENT *thisev = &eventlist[i];   /* Cache of the current event */
switch (thisev->type) {
case EV_SEND:
if (!thisev->s.send.buffer)
thisev->s.send.buffer = NULL;
if (thisev->s.send.verification)
//ncptl_fill_buffer (CONC_GETBUFPTR(send), thisev->s.send.bufferofs + thisev->s.send.size, -1);
break;

case EV_RECV:
if (!thisev->s.recv.buffer)
thisev->s.recv.buffer = NULL;
if (thisev->s.recv.verification)
//ncptl_fill_buffer (CONC_GETBUFPTR(recv), thisev->s.recv.bufferofs + thisev->s.recv.size, -1);
break;

default:
break;
}
}
}

/* Process a subset of the events in a given event list. */
static void conc_process_events (CONC_EVENT *eventlist,
ncptl_int firstev, ncptl_int lastev, ncptl_int numreps)
{
CONC_EVENT * thisev;   /* Cache of the current event */
CONC_EVENT * thisev_first = &eventlist[firstev];   /* Cache of the first event */
ncptl_int i;   /* Iterate over events. */
ncptl_int j;   /* Iterate over repetitions. */

 /* Declarations specific to the c_union backend */
UNION_Status status;   /* Not needed but required by MPI_Recv() */

 /* Process from event firstev to event lastev (both inclusive). */
for (j=numreps; j>0; j--)
for (i=firstev, thisev=thisev_first; i<=lastev; i++, thisev++) {
 /* Declare variables needed by all C-based backends. */

 /* Process a single event. */
switch (thisev->type) {
case EV_SEND:
 /* Synchronous send */
(void) UNION_MPI_Send (NULL,
(int)thisev->s.send.size, MPI_BYTE,
(int)thisev->s.send.dest, (int)thisev->s.send.tag, MPI_COMM_WORLD);
break;

case EV_RECV:
 /* Synchronous receive */
(void) UNION_MPI_Recv (NULL,
(int)thisev->s.recv.size, MPI_BYTE,
(int)thisev->s.recv.source, (int)thisev->s.recv.tag,
MPI_COMM_WORLD, &status);
break;

case EV_RESET:
 /* Reset all of the counters exported to coNCePTuaL programs. */
starttime = ncptl_time();
break;

case EV_FLUSH:
 /* Force all aggregate functions to produce a result. */
if (!suppress_output) {
uint64_t stop_elapsed_usecs = ncptl_time();
var_elapsed_usecs = stop_elapsed_usecs - starttime;
ncptl_log_compute_aggregates (logstate);
starttime += ncptl_time() - stop_elapsed_usecs;
}
break;

case EV_REPEAT:
 /* Repeatedly perform the next batch of events. */
conc_process_events (eventlist, i+1, thisev->s.rep.end_event, thisev->s.rep.numreps);
i = thisev->s.rep.end_event;
thisev = &eventlist[i];
break;

case EV_CODE:
 /* Execute an arbitrary piece of code. */
switch (thisev->s.code.number) {
case 0:
 /* TASK 0LL LOGS "Bytes" AND "1/2 RTT (usecs)" */
if (!suppress_output) {
uint64_t stop_elapsed_usecs = ncptl_time();
var_elapsed_usecs = stop_elapsed_usecs - starttime;
ncptl_log_write (logstate, 0, "Bytes", NCPTL_FUNC_ONLY, 0.0, (double)thisev->s.code.var_msgsize);
ncptl_log_write (logstate, 1, "1/2 RTT (usecs)", NCPTL_FUNC_MEDIAN, 0.0, ((double)var_elapsed_usecs)/(2.0));
starttime += ncptl_time() - stop_elapsed_usecs;
}
break;

default:
 /* The C code generation module must be broken. */
ncptl_fatal ("Internal error: unknown EV_CODE block %" NICS, thisev->s.code.number);
break;
}
break;

default:
 /* The c_generic backend or the c_union backend must be broken. */
ncptl_fatal ("Internal error: unknown event type %d", thisev->type);
break;
}
}
}

/* Finish up cleanly and return a status code. */
static int conc_finalize (void)
{
int exitcode = 0;   /* Program exit code (to pass to exit()) */

 /* Declarations specific to the c_union backend */
int mpiresult;   /* Return code from MPI_Finalize() */

 /* Inform the run-time library that it's no longer needed. */
ncptl_queue_empty (eventqueue);
ncptl_free (eventqueue);
ncptl_finalize();

 /* Finalization code specific to the c_union backend */
mpiresult = 0;
UNION_MPI_Finalize();
mpi_is_running = 0;
exitcode = mpiresult!=MPI_SUCCESS;

 /* Return an exit status code. */
return exitcode;
}

/*************************************************************************/
/***************************** MAIN ROUTINE ******************************/
/*************************************************************************/

/* Program execution starts here. */
static int latency_main (int argc, char *argv[])
{
 /* Declare variables needed by all C-based backends. */
CONC_EVENT * eventlist;   /* List of events to execute */
ncptl_int numevents;   /* Number of entries in eventlist[] */

 /* ----- Initialization ----- */
conc_initialize (argc, argv);
eventlist = (CONC_EVENT *) ncptl_queue_contents (eventqueue, 0);
numevents = ncptl_queue_length (eventqueue);
sendrequests = (UNION_Request *) ncptl_queue_contents (sendreqQ, 0);
sendstatuses = (UNION_Status *) ncptl_queue_contents (sendstatQ, 0);
recvrequests = (UNION_Request *) ncptl_queue_contents (recvreqQ, 0);
recvstatuses = (UNION_Status *) ncptl_queue_contents (recvstatQ, 0);
starttime = ncptl_time();

 /* ----- Event-list processing ----- */
conc_process_events (eventlist, 0, numevents-1, 1);

 /* ----- Finalization ----- */
return conc_finalize();
}
/* fill in function pointers for this method */
struct union_conceptual_bench latency_bench =
{
.program_name = "latency",
.conceptual_main = latency_main,
};
